<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<!--Generated by XBook. Do not edit!!!-->
<!--Author: Just van den Broecke-->
<!--Email: just@justobjects.nl-->
<!--See www.justobjects.nl for more info-->
<title>Design of the Framework</title>
<meta HTTP-EQUIV="Pragma" CONTENT="no-cache">
<style type="text/css" ID="DocStyles">
                
	BODY, .MAIN, .ABSTRACT 
	{
	     background: #ffffff;   
	     color: #000066;
	 	 line-height: 16px;
	     font-size: 11px;
	     font-family : Verdana, Helvetica, Arial, sans-serif;
	}
	
	.ABSTRACT 
	{ 
	     font-style : italic;
		font-family : Georgia, "Times New Roman", serif;
	}

	BODY 
	{ 
	    margin-left: 5%; 
	    margin-right: 24%; 
	}
	
	.NAV
	{
		font-size: 11px;
	}

	H1, H2, H3, H4, H5, H6, .H7, .H8, .TITLE
	{ 
	     color: #990033; 
	}
	
	.TITLE 
	{ 
	     font-size: 24px;
	}
	
	H1 
	{ 
	     font-size: 16px;
	}
	
	H2 
	{ 
	     font-size: 14px;
	}
	
	H3 
	{ 
	     font-size: 12px;
	}
	
	H4 
	{ 
	     font-size: 11px;
	}

	H5 
	{ 
	     font-style : italic; 
	     font-size: 11px;
	}

	H6 
	{ 
	     font-style : italic; 
	     font-weight : normal; 
	     font-size: 11px;
	}

	.H7, .H8 
	{ 
	     font-weight : normal; 
	     font-size: 11px;
	}
	
	.LISTING
	{
	    background-color: #F0F0F0; 
	    color: #000000; 
	    font-size: 11px;
		font-family : "Courier New", Courier, monospaced;
	}
                     
</style>
</head>
<body marginwidth="0">
<table cellpadding="8" border="0">
<tr>
<td>
<div class="NAV">
<a href="whitepaper-s5.html">Previous</a> |
				<a href="whitepaper.html">Up</a>
					| <a href="whitepaper-s7.html">Next</a>
</div>
</td><td><i>
<div class="NAV">Pushlets - Whitepaper</div>
</i></td><td>
<div class="NAV">
<a href="whitepaper-toc.html">TOC</a>
						| <a href="whitepaper-refs.html">Refs</a>
</div>
</td>
</tr>
</table>
<hr>
<a name="A1265375182629"></a><A name="s6."></A>
<h1>6. Design of the Framework</h1>
<div class="MAIN">
	
<B><I>THIS STILL REFLECTS VERSION 1 (REWORKING...).
</I></B>

<P>
The Pushlet framework allows clients to subscribe to subjects within a server from which they subsequently
receive events. The framework's basic design pattern is Publish-Subscribe also known as Observer and
has both server and client components:
</P>


<UL>

<LI>
A server-side collection of Java classes designed around the Pushlet class (see UML class diagram).
</LI>

<LI>
A client-side reusable JavaScript library (pushlet.js) and HTML (pushlet.html)
for receiving events within DHTML clients.
</LI>

<LI>
Client-side Java classes (JavaPushletClient.java and JavaPushletClientListener.java)
for receiving events within Java clients.
</LI>

<LI>
Cross-browser DHTML utility libraries (layer.js, layer-grid.js, layer-region.js) for displaying content in DHTML layers.
</LI>

<LI>
Generation of test events (EventGenerators.java) and example applications (e.g. temperature.html).
</LI>

</UL>

<a name="A1265375182632"></a><A name="s6.1."></A>
<h2>6.1. Server-side class design</h2>
<div class="MAIN">

<P>
Below is the UML class diagram of the server-side Java classes <B><I>[reflects v0.0.4; rework required]</I></B>.
</P>

<CENTER>

<IMG src="assets/pushlet-class-diagram.gif" border="0">
<P>

<B><I>Figure 1. Pushlet Framework Class Diagram. </I></B>

</P>

</CENTER>

<P>
The key classes are the Pushlet servlet, the Publisher class, Subscriber interface, and the 
Event class (see class diagram). 
By invoking the Pushlet servlet through an HTTP request, clients subscribe to receive Events. In the request is
indicated:
</P>


<UL>

<LI>
for which "subject" they would like to receive Events. </LI>

<LI>in which format (JavaScript calls (default), XML or Java serialized objects) they should receive Events and,</LI>

<LI>through which receiver protocol (future version)</LI>

</UL>

<P>
An example request for receiving AEX stock rates formatted as JavaScript through an HTTP response stream would be:
</P>

<table cellspacing="0" cellpadding="1" border="0" bgcolor="black">
<tr>
<td>
<table width="100%" cellspacing="0" cellpadding="20" border="0" bgcolor="#F0F0F0">
<tr>
<td>
<pre>
<div class="LISTING">
http://www.fluidiom.com:8080/servlet/pushlet?subject="/stocks/aex"
</div>
</pre>
</td>
</tr>
</table>
</td>
</tr>
</table>

<P>
Subject identifiers are organized as an hierarchical "topic-tree". For example,
"/stocks" identifies all Events related to stock rates, while "/stocks/aex" identifies stock rates for the
Amsterdam EXchange. Likewise the subject "/" indicates all events. 
</P>

<P>
Currently the only receiver protocol is a client HTTP response stream.
In a future extension also the receiver protocol and address
can be indicated, e.g. TCP, UDP, RMI, HTTP POSTing, or even SMTP (email).
</P>

<P>
An Event is merely a set of name/value String pairs (implemented with java.util.Properties). The Publisher has an interface
through which classes that generate Events can publish them. The Publisher keeps a list of Subscribers and sends
each Event to those Subscribers whose subject matches to the Event's subject. Events may be originating within
the server through EventGenerators who may listen to external events such as a stock feed. In addition clients
may publish Events through HTTP with the Postlet class. The responsibilities of other classes in class diagram, PushletSubscriber and its contained classes can best
be explained through scenario's. 
</P>

<a name="A1265375182635"></a><A name="s6.1.1."></A>
<h3>6.1.1. Scenario: Event Subscription</h3>
<div class="MAIN">

<CENTER>

<IMG src="assets/seq-subscribe.gif" border="0">
<P>

<B><I>Figure 2. Subscribe Sequence Diagram. </I></B>

</P>

</CENTER>

<P>
Above is the UML sequence diagram for a browser client subscribing
for events from the Publisher. The Pushlet is invoked with the servlet method doGet(). Because multiple
clients may invoke the same Pushlet object, it should itself not be a Subscriber. Instead it delegates all
subscription (and subsequent Event handling) by creating a new PushletSubscriber object for each doGet()
and letting it run until finished with eventLoop(). The PushletSubscriber is a Subscriber object towards
the Publisher where it registers with the join() method. To deal with different client formats and protocols it 
creates a specialized ClientAdapter object, in this case a BrowserPushletAdapter. For browsers supporting
Multipart MIME such as Netscape 4+, this would be a MultipartBrowserClientAdapter. The final call in this scenario
is a "wait for event loop". Note that deQueue() is a method that suspends the execution of the current thread
until an Event becomes available (indicated with half-arrow). This is explained through the next scenario.
</P>

</div>

<a name="A1265375182636"></a><A name="s6.1.2."></A>
<h3>6.1.2. Scenario: Sending and Dispatching Events</h3>
<div class="MAIN">

<CENTER>

<IMG src="assets/seq-publish.gif" border="0">
<P>

<B><I>Figure 3. Publish Sequence Diagram. </I></B>

</P>

</CENTER>

<P>
Above is the UML sequence diagram for sending an Event. It
 shows how an Event is generated and dispatched to the browser client. 
In this scenario an EventGenerator
creates an Event and calls Publisher.publish() to have it dispatched. The Publisher walks through its
list of Subscribers and asks each if the Event matches its subscription criteria (currently only the
subject). If it matches it calls send() on the Subscriber. 
</P>


<P>
Each PushletSubscriber object has
a GuardedQueue object in which it queues incoming Events when send() is called. So why isn't it just
directly pushing the Event to the BrowserPushletAdapter ? First of all we want to suspend execution of the 
BrowserPushletAdapter-thread until an Event becomes available, i.e. we don't want to do a "busy-wait" (a.k.a. as polling).
The second reason is that a Publisher may notify multiple clients. Having a synchronous send() call a slow client
on the other end of the line may block all other clients that are to be notified next. This is actually a 
design pitfall which I see also in RMI or CORBA callback examples where a list of clients is called
back synchronously. Client #13 on a slow connection and 386 processor may spoil it for the rest.
</P>

<P>
The GuardedQueue is a utility object that allows Objects to be en/dequeued using the readers-writers pattern
with guarded suspension using java.lang.Object.wait() and notifyAll(). The thread of a client of GuardedQueue
calling deQueue() will be suspended (using wait()) until there is an Object queued. Likewise a client enQueueing
an Object will be suspended as long as the queue is full.  When clients are fast enough the GuardedQueue is never
filling up. After the BrowserPushletSubscriber has dequeued an Event object it will call push() on the 
BrowserPushletAdapter who will format the Event to a JavaScript element and send it to the browser.
For example for a Philips stock rate of 123.45 the JavaScript element looks as follows.
</P>

<table cellspacing="0" cellpadding="1" border="0" bgcolor="black">
<tr>
<td>
<table width="100%" cellspacing="0" cellpadding="20" border="0" bgcolor="#F0F0F0">
<tr>
<td>
<pre>
<div class="LISTING">
&lt;SCRIPT language=JavaScript &gt;parent.push('subject', '/stocks/aex', 'philips', '123.45') &lt;/SCRIPT&gt;
</div>
</pre>
</td>
</tr>
</table>
</td>
</tr>
</table>

</div>

</div>


<a name="A1265375182638"></a><A name="s6.2."></A>
<h2>6.2. Client-side framework</h2>
<div class="MAIN">

<P>
By now we have arrived on the client browser side. The Pushlet itself was assigned to a hidden
HTML FRAME. The parent of that FRAME is called and has to implement the push() method. Since this
is a common task for all browser clients, two reusable files are provided for the client: pushlet.html
(see /src/nl/justobjects/pushlet/pushlet.html) and pushlet.js (see /src/nl/justobjects/pushlet/pushlet.js).
</P>

<P>
pushlet.html is meant to be included in a FRAME within the application-specific client HTML document. It
can be parameterized with the subject identifier and a background color (such that it remains invisible).
The most important thing it does is implementing the JavaScript push() method as follows:
</P>

<table cellspacing="0" cellpadding="1" border="0" bgcolor="black">
<tr>
<td>
<table width="100%" cellspacing="0" cellpadding="20" border="0" bgcolor="#F0F0F0">
<tr>
<td>
<pre>
<div class="LISTING">
function push() {
	// Create a PushletEvent object from the arguments passed in
	// push.arguments is event data coming from the Server 
        pushletEvent = new PushletEvent(push.arguments)

        // Show blinking light as data is coming in
	updateStatusFrame();
	
	// Is parent ready to receive events ?
	if (!parent.onPush) {
		return;
	}
	
	// Forward the event to the parent frame who should do application
	// specific handling of the event
	parent.onPush(pushletEvent);
}
</div>
</pre>
</td>
</tr>
</table>
</td>
</tr>
</table>

<P>
The function push() first creates a JavaScript object from the parameters passed in. Yes you can do object-based
programming in JavaScript. Reminiscent of 'varargs' in C/C++, JavaScript functions may have variable
number of arguments. A PushletEvent object is created with whatever arguments were passed to push() from
the server. PushletEvent is implemented in pushlet.js shown next.
</P>

<table cellspacing="0" cellpadding="1" border="0" bgcolor="black">
<tr>
<td>
<table width="100%" cellspacing="0" cellpadding="20" border="0" bgcolor="#F0F0F0">
<tr>
<td>
<pre>
<div class="LISTING">
/* Object to represent nl.justobjects.pushlet.Event in JavaScript. 
   Arguments are an array where args[i] is name and args[i+1] is value 
*/
function PushletEvent(args) {
   // Member variable setup; the Map stores the N/V pairs
   this.map = new Map();
   
   // Member function setup
   this.getSubject = PushletEventGetSubject
   this.put = PushletEventPut
   this.get = PushletEventGet
   this.toString = PushletEventToString
   this.toTable = PushletEventToTable

   // Put the arguments' name/value pairs in the Map
   for (var i=0; i &lt; args.length; i++) {
     this.put(args[i], args[++i] );
   }
}

// Get the subject attribute
function PushletEventGetSubject() {
  return this.map.get('subject')
}

// Get event attribute
function PushletEventGet(name) {
  return this.map.get(name)
}

// Put event attribute
function PushletEventPut(name, value) {
  return this.map.put(name, value)
}

function PushletEventToString() {
  return this.map.toString();
}

// Convert content to HTML TABLE
function PushletEventToTable() {
  return this.map.toTable();
}

</div>
</pre>
</td>
</tr>
</table>
</td>
</tr>
</table>

<P>
pushlet.js in turn uses a Map JavaScript object, a java.util.Hashtable-like object I've added.
</P>

<P>
Next push() calls updateStatusFrame() to show a blinking light to indicate we are still receiving
events and if a parent.onPush() function exists, it calls it with the PushletEvent. parent.onPush() is the
application-specific event handling function that in this case may update the 'philips' stock-related Layer
in a DHTML page.
</P>

<P>
This ends the description of the basic framework design. 
</P>

</div>

</div>
<hr>
<table cellpadding="8" border="0">
<tr>
<td>
<div class="NAV">
<a href="whitepaper-s5.html">Previous</a> |
				<a href="whitepaper.html">Up</a>
					| <a href="whitepaper-s7.html">Next</a>
</div>
</td><td><i>
<div class="NAV">Pushlets - Whitepaper</div>
</i></td><td>
<div class="NAV">
<a href="whitepaper-toc.html">TOC</a>
						| <a href="whitepaper-refs.html">Refs</a>
</div>
</td>
</tr>
</table>
</body>
</html>
